// Generated by BUCKLESCRIPT VERSION 1.9.3, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function $neg$neg(i, j) {
  var _n = j - 1 | 0;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var n = _n;
    var match = +(n < i);
    if (match !== 0) {
      return acc;
    } else {
      _acc = /* :: */[
        n,
        acc
      ];
      _n = n - 1 | 0;
      continue ;
      
    }
  };
}

function $neg$neg$neg(i, j) {
  var _n = j;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var n = _n;
    var match = +(n < i);
    if (match !== 0) {
      return acc;
    } else {
      _acc = /* :: */[
        n,
        acc
      ];
      _n = n - 1 | 0;
      continue ;
      
    }
  };
}

var directions = /* :: */[
  /* NNW */0,
  /* :: */[
    /* NNE */1,
    /* :: */[
      /* ENE */2,
      /* :: */[
        /* ESE */3,
        /* :: */[
          /* SSE */4,
          /* :: */[
            /* SSW */5,
            /* :: */[
              /* WSW */6,
              /* :: */[
                /* WNW */7,
                /* [] */0
              ]
            ]
          ]
        ]
      ]
    ]
  ]
];

function getValidMoves(n, param) {
  var y = param[1];
  var x = param[0];
  var aux = function (direction) {
    switch (direction) {
      case 0 : 
          var match = +((x - 1 | 0) >= 0 && (y - 2 | 0) >= 0);
          if (match !== 0) {
            return /* tuple */[
                    x - 1 | 0,
                    y - 2 | 0
                  ];
          } else {
            return /* tuple */[
                    -1,
                    -1
                  ];
          }
      case 1 : 
          var match$1 = +((x + 1 | 0) < n && (y - 2 | 0) >= 0);
          if (match$1 !== 0) {
            return /* tuple */[
                    x + 1 | 0,
                    y - 2 | 0
                  ];
          } else {
            return /* tuple */[
                    -1,
                    -1
                  ];
          }
      case 2 : 
          var match$2 = +((x + 2 | 0) < n && (y - 1 | 0) >= 0);
          if (match$2 !== 0) {
            return /* tuple */[
                    x + 2 | 0,
                    y - 1 | 0
                  ];
          } else {
            return /* tuple */[
                    -1,
                    -1
                  ];
          }
      case 3 : 
          var match$3 = +((x + 2 | 0) < n && (y + 1 | 0) < n);
          if (match$3 !== 0) {
            return /* tuple */[
                    x + 2 | 0,
                    y + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    -1,
                    -1
                  ];
          }
      case 4 : 
          var match$4 = +((x + 1 | 0) < n && (y + 2 | 0) < n);
          if (match$4 !== 0) {
            return /* tuple */[
                    x + 1 | 0,
                    y + 2 | 0
                  ];
          } else {
            return /* tuple */[
                    -1,
                    -1
                  ];
          }
      case 5 : 
          var match$5 = +((x - 1 | 0) >= 0 && (y + 2 | 0) < n);
          if (match$5 !== 0) {
            return /* tuple */[
                    x - 1 | 0,
                    y + 2 | 0
                  ];
          } else {
            return /* tuple */[
                    -1,
                    -1
                  ];
          }
      case 6 : 
          var match$6 = +((x - 2 | 0) >= 0 && (y + 1 | 0) < n);
          if (match$6 !== 0) {
            return /* tuple */[
                    x - 2 | 0,
                    y + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    -1,
                    -1
                  ];
          }
      case 7 : 
          var match$7 = +((x - 2 | 0) >= 0 && (y - 1 | 0) >= 0);
          if (match$7 !== 0) {
            return /* tuple */[
                    x - 2 | 0,
                    y - 1 | 0
                  ];
          } else {
            return /* tuple */[
                    -1,
                    -1
                  ];
          }
      
    }
  };
  var validMapPositions = List.map(aux, directions);
  return List.fold_left((function (agg, x) {
                var match = +(x[0] === -1);
                if (match !== 0) {
                  return agg;
                } else {
                  return /* :: */[
                          x,
                          agg
                        ];
                }
              }), /* [] */0, validMapPositions);
}

function willHeDie(n, k, x, y) {
  var expandMoves = function (_k, position, _movesToExpand) {
    while(true) {
      var movesToExpand = _movesToExpand;
      var k = _k;
      if (k !== 0) {
        var validMoves = getValidMoves(n, position);
        _movesToExpand = List.concat(/* :: */[
              validMoves,
              /* :: */[
                movesToExpand,
                /* [] */0
              ]
            ]);
        _k = k - 1 | 0;
        continue ;
        
      } else {
        return movesToExpand;
      }
    };
  };
  var initialPosition = /* tuple */[
    x,
    y
  ];
  var allPositions = expandMoves(k, initialPosition, /* [] */0);
  return List.length(allPositions) / Math.pow(List.length(directions), k);
}

console.log(Pervasives.string_of_float(willHeDie(3, 2, 0, 0)));

exports.$neg$neg      = $neg$neg;
exports.$neg$neg$neg  = $neg$neg$neg;
exports.directions    = directions;
exports.getValidMoves = getValidMoves;
exports.willHeDie     = willHeDie;
/*  Not a pure module */
